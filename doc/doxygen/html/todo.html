<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UQTk: Uncertainty Quantification Toolkit: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">UQTk: Uncertainty Quantification Toolkit
   &#160;<span id="projectnumber">3.0.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Todo List </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt><a class="anchor" id="_todo000001"></a>Class <a class="el" href="classArray1D.html">Array1D&lt; T &gt;</a>  </dt>
<dd>double check copy constructor  </dd>
<dt><a class="anchor" id="_todo000002"></a>Class <a class="el" href="classArray2D.html">Array2D&lt; T &gt;</a>  </dt>
<dd>Define copy constructor  </dd>
<dt><a class="anchor" id="_todo000003"></a>Class <a class="el" href="classArray3D.html">Array3D&lt; T &gt;</a>  </dt>
<dd><p class="startdd">Define copy constructor </p>
<p class="enddd">Several functions, e.g. insert/erase columns/rows, available in <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> and <a class="el" href="classArray2D.html" title="Stores data of any type T in a 2D array. ">Array2D</a>, are missing.  </p>
</dd>
<dt><a class="anchor" id="_todo000004"></a>Member <a class="el" href="classArray3D.html#ac8640825b685d374f1b499c97891ba97">Array3D&lt; T &gt;::Resize</a>  (const size_t &amp;nx, const size_t &amp;ny, const size_t &amp;nz)</dt>
<dd>Write a better implementation that preserves the original data by copying it to a temporary array and putting the elements back where they were before. This would bring this resize() command more closely in line with vector::resize() function in the original vector class.  </dd>
<dt><a class="anchor" id="_todo000005"></a>Member <a class="el" href="classArray3D.html#ac1991b560439af5dabfb093c056cdbf7">Array3D&lt; T &gt;::Resize</a>  (const size_t &amp;nx, const size_t &amp;ny, const size_t &amp;nz, const T &amp;t)</dt>
<dd>Write an implementation that is more closely follows the resize command in the vector class, which keeps the original elements and only initializes the new elements.  </dd>
<dt><a class="anchor" id="_todo000006"></a>File <a class="el" href="arraytools_8h.html">arraytools.h</a>  </dt>
<dd><p class="startdd">Some functions are not optimal in terms of array access. </p>
<p class="enddd">Some functions should be templated and or moved to array class  </p>
</dd>
<dt><a class="anchor" id="_todo000013"></a>Member <a class="el" href="bcs_8h.html#a37e7640e112c05716e1a15d3854a9a35">BCS</a>  (<a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;PHI, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;y, double &amp;sigma2, double eta, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;lambda_init, int adaptive, int optimal, double scale, int verbose, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;weights, <a class="el" href="classArray1D_3_01int_01_4.html">Array1D&lt; int &gt;</a> &amp;used, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;errbars, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;basis, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;alpha, double &amp;lambda)</dt>
<dd>The array manipulations are not optimized - perhaps they need to be reconsidered using, say, fortran matrix-vector manipulation routines  </dd>
<dt><a class="anchor" id="_todo000011"></a>Member <a class="el" href="arraytools_8h.html#ab282bf9be9d3f828dab3eea48160f934">delCol</a>  (Array1D&lt; T &gt; &amp;x, int icol)</dt>
<dd>This should move to <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> class  </dd>
<dt><a class="anchor" id="_todo000010"></a>Member <a class="el" href="arraytools_8h.html#a5079afb7e1dc27415eb8f983f9051a98">delCol</a>  (Array2D&lt; T &gt; &amp;A, int icol)</dt>
<dd>This should move to <a class="el" href="classArray2D.html" title="Stores data of any type T in a 2D array. ">Array2D</a> class  </dd>
<dt><a class="anchor" id="_todo000009"></a>Member <a class="el" href="arraytools_8h.html#a6335893f712bbd849051e4870ae72993">delRow</a>  (Array2D&lt; T &gt; &amp;A, int irow)</dt>
<dd>This should move to <a class="el" href="classArray2D.html" title="Stores data of any type T in a 2D array. ">Array2D</a> class  </dd>
<dt><a class="anchor" id="_todo000007"></a>Member <a class="el" href="arraytools_8h.html#afe4c308b7d749b067c6decc2d2ea75dc">generate_multigrid</a>  (Array2D&lt; T &gt; &amp;multigrid, Array2D&lt; T &gt; &amp;grid)</dt>
<dd>Should ideally be written in a recursive manner, similar to <a class="el" href="multiindex_8cpp.html#a279f0042f33de462cd660e27001f9ccc" title="Computes the multiindex set of a PC basis for Tensor-Product truncation with a given maximum order pe...">computeMultiIndexTP()</a> in <a class="el" href="multiindex_8cpp.html" title="Tools that deal with integer multiindices. ">tools/multiindex.cpp</a>  </dd>
<dt><a class="anchor" id="_todo000054"></a>Member <a class="el" href="probability_8h.html#a7347fd91b04310145aa6d4e0d93aa92e">generate_normal_lhs</a>  (<a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;rvar, int zSeed)</dt>
<dd>LHS generation is far from optimal, it is quite slow  </dd>
<dt><a class="anchor" id="_todo000019"></a>Member <a class="el" href="classGproc.html#a61f056cd9d478b2cc1c4d4cb99f7bbe9">Gproc::BuildGP_inv</a>  ()</dt>
<dd>Need formal timing analysis to understand in which situations this version is preferred  </dd>
<dt><a class="anchor" id="_todo000018"></a>Member <a class="el" href="classGproc.html#aa1714442ba027c88bdc7c86ad09fd20e">Gproc::covariance</a>  (<a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;x1, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;x2, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;param)</dt>
<dd>put an 'if' check for covtype_  </dd>
<dt><a class="anchor" id="_todo000020"></a>Member <a class="el" href="classGproc.html#abf65e7a8db4929a164165c2725b40429">Gproc::EvalGP_inv</a>  (<a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;xgrid, string msc, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;mst)</dt>
<dd>Need formal timing analysis to understand in which situations this version is preferred  </dd>
<dt><a class="anchor" id="_todo000016"></a>Member <a class="el" href="classGproc.html#a99684ee772ee12c79d4665851df07537">Gproc::getSttPars</a>  (<a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;sttmat)</dt>
<dd>check that full cov_ already defined(i.e. msc) not just diagonal  </dd>
<dt><a class="anchor" id="_todo000017"></a>Member <a class="el" href="classGproc.html#a7505edc4e87baca52c793a2cefde9036">Gproc::getXYCov</a>  (<a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;xgrid, <a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;xycov)</dt>
<dd>check that full cov_ already defined(i.e. msc) not just diagonal  </dd>
<dt><a class="anchor" id="_todo000012"></a>Member <a class="el" href="arraytools_8h.html#a513ef63f2bc77afd31649cafcfbd2498">logdeterm</a>  (<a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;mat)</dt>
<dd>Check and catch the symmetric and positiv-definite conditions.  </dd>
<dt><a class="anchor" id="_todo000021"></a>Member <a class="el" href="lreg_8cpp.html#a375fbcf9ede885a1eb73e9f81827f990">loo</a>  (int ndim, double *m, void *classpointer)</dt>
<dd>Find a more elegant way to do this within the class  </dd>
<dt><a class="anchor" id="_todo000050"></a>Member <a class="el" href="minmax_8h.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a>  </dt>
<dd>See if we could move this to the CMake installation scripts instead  </dd>
<dt><a class="anchor" id="_todo000058"></a>Member <a class="el" href="pce__eval_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>  (int argc, char *argv[])</dt>
<dd>Make the input arguments more transparent, i.e. what do they mean in different scenarios?  </dd>
<dt><a class="anchor" id="_todo000051"></a>File <a class="el" href="multiindex_8h.html">multiindex.h</a>  </dt>
<dd>Multiindex could be a separate class and a part of core UQTk.  </dd>
<dt><a class="anchor" id="_todo000015"></a>Member <a class="el" href="gproc_8cpp.html#a32596f835750b751deb4e7855820dc0d">neglogPostParam</a>  (int ndim, double *m, void *classpointer)</dt>
<dd>Find a more elegant way to do this within the class  </dd>
<dt><a class="anchor" id="_todo000024"></a>Member <a class="el" href="classPCBasis.html#a1b1ca2799fd19e168660e0c760a598bf">PCBasis::EvalBasis</a>  (const double &amp;xi, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;basisEvals) const</dt>
<dd>Import the recursion coefficients in a more friendly fashion.  </dd>
<dt><a class="anchor" id="_todo000023"></a>Member <a class="el" href="classPCBasis.html#a7434a70f3b962f0e375a9a5edd9508ec">PCBasis::Init1dQuadPoints</a>  (int qdpts)</dt>
<dd>Come up with a smarter way to pick the number of quadrature points  </dd>
<dt><a class="anchor" id="_todo000022"></a>Member <a class="el" href="classPCBasis.html#a000d56b87ef6a80ee6dcf4c51a49066f">PCBasis::PCBasis</a>  (const string type="LU", const double alpha=0.0, const double betta=1.0, const int maxord=10)</dt>
<dd>At some point, the basis selection should probably be implemented in a more elegant way using base and inherited classes. For the time being, Hermite-Gaussian or Legendre-Uniform will probably be the most commonly used cases. The parameters alpha and betta are relevant only for GLG, SW and JB chaoses  </dd>
<dt><a class="anchor" id="_todo000025"></a>Member <a class="el" href="classPCBasis.html#add6375d6c2e66eb0ea4ca938bd2875a6">PCBasis::rnstate_</a>  </dt>
<dd>need more functionalities to get/set this variable from user  </dd>
<dt><a class="anchor" id="_todo000052"></a>File <a class="el" href="pcmaps_8h.html">pcmaps.h</a>  </dt>
<dd><p class="startdd">Perhaps use more robust tools, like dcdflib. </p>
<p class="enddd">Need more testing of these tools.  </p>
</dd>
<dt><a class="anchor" id="_todo000045"></a>Member <a class="el" href="classPCSet.html#a96b16eea0c145deed7a14fa02490883d">PCSet::ComputeJointSens</a>  (<a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;coef, <a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;jointsens)</dt>
<dd>There is no double* version of this function  </dd>
<dt><a class="anchor" id="_todo000043"></a>Member <a class="el" href="classPCSet.html#abf1c360cc8e305e50a1d418cc084550b">PCSet::ComputeMainSens</a>  (<a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;coef, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;mainsens)</dt>
<dd>There is no double* version of this function  </dd>
<dt><a class="anchor" id="_todo000041"></a>Member <a class="el" href="classPCSet.html#a99b0d9532eff6f625b5db8583354f9d5">PCSet::ComputeOrders</a>  (<a class="el" href="classArray1D_3_01int_01_4.html">Array1D&lt; int &gt;</a> &amp;orders)</dt>
<dd>There is no double* version of this function  </dd>
<dt><a class="anchor" id="_todo000044"></a>Member <a class="el" href="classPCSet.html#a4dc8071222615802f791f74ddb06f9a7">PCSet::ComputeTotSens</a>  (<a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;coef, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;totsens)</dt>
<dd>There is no double* version of this function  </dd>
<dt><a class="anchor" id="_todo000034"></a>Member <a class="el" href="classPCSet.html#a5befcdf8e9fb6f04b31c606bd4e82425">PCSet::Derivative</a>  (const double *p1, double *p2) const</dt>
<dd><p class="startdd">Supports LU and HG bases only </p>
<p class="enddd">Supports only for 1d PCs  </p>
</dd>
<dt><a class="anchor" id="_todo000035"></a>Member <a class="el" href="classPCSet.html#a72380baa924cdefd210ea2991230f64a">PCSet::Derivative</a>  (const <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;p1, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;p2) const</dt>
<dd><p class="startdd">Supports LU and HG bases only </p>
<p class="enddd">Supports only for 1d PCs  </p>
</dd>
<dt><a class="anchor" id="_todo000031"></a>Member <a class="el" href="classPCSet.html#a701974ac7e77fc8ef60b0d1e8c0b214d">PCSet::Div</a>  (const double *p1, const double *p2, double *p3) const</dt>
<dd>Remove duplication of data and parameters that was required for enforcing imposed "const" constraints on some of the arguments and the class data members when they are being passed to fortran.  </dd>
<dt><a class="anchor" id="_todo000036"></a>Member <a class="el" href="classPCSet.html#adc5be6730a36af91d15bd722599ba65e">PCSet::DrawSampleVar</a>  (<a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;samples) const</dt>
<dd>There is no double* version of this function  </dd>
<dt><a class="anchor" id="_todo000042"></a>Member <a class="el" href="classPCSet.html#ad385fc95c37e6b87603e676120d304be">PCSet::EncodeMindex</a>  (<a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a>&lt; <a class="el" href="classArray2D.html">Array2D&lt; int &gt;</a> &gt; &amp;sp_mindex)</dt>
<dd>There is no double* version of this function  </dd>
<dt><a class="anchor" id="_todo000038"></a>Member <a class="el" href="classPCSet.html#a8dc2cf2106a31b170bedd48be02bf179">PCSet::EvalBasisAtCustPts</a>  (const <a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;custPoints, <a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;psi)</dt>
<dd>There is no double* version of this function  </dd>
<dt><a class="anchor" id="_todo000046"></a>Member <a class="el" href="classPCSet.html#a06722aecd7b0201b4a4e5c743ea4045f">PCSet::EvalNormSq</a>  (<a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;normsq)</dt>
<dd>There is no double* version of this function  </dd>
<dt><a class="anchor" id="_todo000047"></a>Member <a class="el" href="classPCSet.html#a29b42d8259a2f8dd8f2cf47cbcd7aa8e">PCSet::EvalNormSqExact</a>  (<a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;normsq)</dt>
<dd>There is no double* version of this function  </dd>
<dt><a class="anchor" id="_todo000037"></a>Member <a class="el" href="classPCSet.html#a1cf513a3e88ed2842fa99a2c510f16a3">PCSet::EvalPCAtCustPoints</a>  (<a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;xch, <a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;custPoints, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;p)</dt>
<dd>There is no double* version of this function  </dd>
<dt><a class="anchor" id="_todo000039"></a>Member <a class="el" href="classPCSet.html#a02aada88e0176ac83439a9c0ce587b6b">PCSet::GalerkProjection</a>  (const <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;fcn, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;ck)</dt>
<dd><p class="startdd">Overload this with forward function pointers </p>
<p class="enddd">There is no double* version of this function  </p>
</dd>
<dt><a class="anchor" id="_todo000040"></a>Member <a class="el" href="classPCSet.html#a2269cbf763ed3d5f396dbfc187f6772b">PCSet::GalerkProjectionMC</a>  (const <a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;x, const <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;fcn, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;ck)</dt>
<dd><p class="startdd">Overload this with forward function pointers </p>
<p class="enddd">There is no double* version of this function  </p>
</dd>
<dt><a class="anchor" id="_todo000027"></a>Member <a class="el" href="classPCSet.html#a159ac0dfca1d5b7102b8e5b583b20e68">PCSet::GetNormSq</a>  (<a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;normsq) const</dt>
<dd>this seems like a duplication, see below <a class="el" href="classPCSet.html#a8231031e57cd7a26ff5051202b006a0a" title="Get the basis polynomial norms-squared in an array class object psisq. ">GetPsiSq()</a>  </dd>
<dt><a class="anchor" id="_todo000048"></a>Member <a class="el" href="classPCSet.html#a849c4c41a7be1444c7255375874d7e8e">PCSet::Initialize</a>  (const string ordertype)</dt>
<dd>Test and allow intrusive implementation with customized multiindices  </dd>
<dt><a class="anchor" id="_todo000029"></a>Member <a class="el" href="classPCSet.html#af9dc098a60eabf69794c8b27559ec83d">PCSet::InitMeanStDv</a>  (const double &amp;m, const double &amp;s, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;p) const</dt>
<dd>Make this function work for general multi-indices, and for any number of stochastic dimensions  </dd>
<dt><a class="anchor" id="_todo000028"></a>Member <a class="el" href="classPCSet.html#af6242816c202727e8edcc5bd695ca2ac">PCSet::InitMeanStDv</a>  (const double &amp;m, const double &amp;s, double *p) const</dt>
<dd>Make this function work for general multi-indices, and for any number of stochastic dimensions  </dd>
<dt><a class="anchor" id="_todo000049"></a>Member <a class="el" href="classPCSet.html#adf4e158bc9d58d417047a0cf0370a57d">PCSet::LogIntRhsWrapper</a>  (realtype t, N_Vector y, N_Vector ydot, void *f_data)</dt>
<dd>Why is this function a static int instead of static void? Should there be a return statement at the end?  </dd>
<dt><a class="anchor" id="_todo000030"></a>Member <a class="el" href="classPCSet.html#a248b0bf9b27e9015fed6f791beb854ea">PCSet::PolynMulti</a>  (const <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;polycf, const <a class="el" href="classArray2D.html">Array2D&lt; int &gt;</a> &amp;mindex, const <a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;p1, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;p2) const</dt>
<dd>A double* version should be added.  </dd>
<dt><a class="anchor" id="_todo000026"></a>Member <a class="el" href="classPCSet.html#a993d6c600aad5e25e0e0311598cbc047">PCSet::SetQuadRule</a>  (const string grid_type, const string fs_type, int param)</dt>
<dd>Need to improve it  </dd>
<dt><a class="anchor" id="_todo000032"></a>Member <a class="el" href="classPCSet.html#ab5a08bac771c397cd9d0096b667a17fb">PCSet::StDv</a>  (const double *p) const</dt>
<dd>Lift the assumption by looking for the constant term in the multiindex  </dd>
<dt><a class="anchor" id="_todo000033"></a>Member <a class="el" href="classPCSet.html#a4721d86ad8ce4ffa3535f60e23287318">PCSet::StDv</a>  (const <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;p) const</dt>
<dd>Lift the assumption by looking for the constant term in the multiindex  </dd>
<dt><a class="anchor" id="_todo000053"></a>File <a class="el" href="probability_8h.html">probability.h</a>  </dt>
<dd>There shuold be a RNG class as a part of core UQTk - most of these functions will fit there.  </dd>
<dt><a class="anchor" id="_todo000055"></a>Member <a class="el" href="classQuad.html#a5df24a12fdbed7e3d4d9d28e0677c923">Quad::create1DRule_pdf</a>  (<a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;qdpts, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;wghts, int ngr, double a, double b)</dt>
<dd>Recursive coefficients are given in a file 'ab.dat'; will need to make this more friendly  </dd>
<dt><a class="anchor" id="_todo000008"></a>Member <a class="el" href="arraytools_8h.html#a4ad5a87ae0b31ba9e14e84fc0de0199e">setdiff_s</a>  (<a class="el" href="classArray1D_3_01int_01_4.html">Array1D&lt; int &gt;</a> &amp;A, <a class="el" href="classArray1D_3_01int_01_4.html">Array1D&lt; int &gt;</a> &amp;B, <a class="el" href="classArray1D_3_01int_01_4.html">Array1D&lt; int &gt;</a> &amp;C)</dt>
<dd>In future, this should sort A too and replace setdiff  </dd>
<dt><a class="anchor" id="_todo000057"></a>Member <a class="el" href="pce__rv_8cpp.html#ad876cdd1a72412cf2e0d2fcde266dd9a">usage</a>  ()</dt>
<dd>Add more detailed information on options. E.g. what are the different options for type of random variable? When does the order need to be specified?  </dd>
<dt><a class="anchor" id="_todo000014"></a>Member <a class="el" href="bcs_8h.html#adc1df47b49e925aba2a5067732f74188">WBCS</a>  (<a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;PHI, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;y, double &amp;sigma2, double eta, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;lambda_init, int adaptive, int optimal, double scale, int verbose, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;weights, <a class="el" href="classArray1D_3_01int_01_4.html">Array1D&lt; int &gt;</a> &amp;used, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;errbars, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;basis, <a class="el" href="classArray1D_3_01double_01_4.html">Array1D&lt; double &gt;</a> &amp;alpha, double &amp;lambda, <a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;Sig)</dt>
<dd>The array manipulations are not optimized - perhaps they need to be reconsidered using, say, fortran matrix-vector manipulation routines  </dd>
<dt><a class="anchor" id="_todo000056"></a>Member <a class="el" href="classXMLElement.html#a03ab18d6c6f234b9ec741b8f2d9b629c">XMLElement::get_child</a>  (const std::string &amp;)</dt>
<dd>Make this more elegant with the STL find_if function </dd>
</dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
